<!-- 
    comments in html look like this :(
-->

<link rel="stylesheet" href="css/style.css"> 

<title> 
    project euler problem solutions
</title>

<li>
    <a target="_top"> 
        homepage </a>
</li>
<li>
    <a target="_parent"> 
        coding shit </a>
</li>

<p>
    some of my methods for solving some project euler problems i found interesting/challenging. <br>
    spoilers ahead if you want to try for yourself do not look at solutions. <br>
    it is very unlikely these are optimals solutions. <br><br>

</p>

<p>
    <p style="font-size: 24px;"> #31 - Coin Sums </p>
    how many ways can you make $2 using the following coins: {1c, 2c, 5c, 10c, 20c, 50c, $1, $2}? <br>
    <br>
    initial thoughts, i'll define p(n) to be the number of ways you can reach n using the set of coins. <br>
    this means p(0) = p(1) = 1. the goal is to find p(200).<br>
    p(n) must be a non-decreasing function because you can attach 1c to every solution for the previous n. <br>
    so p(n) >= p(n-1). can i repeat this process for the other coins. so for applying the same logic as the 1c we know p(n) >= p(n-2). <br>
    so if i account for all coins like this we get p(n) = Σ꜀ p(n-c), for c in coins. <br>
    unfortunately this double counts many solutions i.e. one solution to p(4) is (2, 1, 1) and a solution to p(5) is (2, 2, 1) <br>
    the method described above would get (2, 1, 1, 2) as a solution to p(6) twice. (2, 1, 1) + (2) and (2, 2, 1) + (1)<br>
    <br> 
    to stop double counting is to make sure the coins picked in descending order. so if a coin c is picked, then no coin greater then c can be picked until the target is reached. <br>
    this ensures that all solutions which reach the target are unique. and therefore a simple recursive solution is applicable. <br>
    since target and coin set were not very big i didnt bother trying to optimise anymore. i know this is a slow solution, lots of redundant calculations. <br>
    pe difficulty: 5/100<br>
    my rating: 10/100 <br>
    <a href="projecteuler/coinsums attempt 2.png" target="_blank"> show solution </a>
    <br><br><br>    

</p>

<p>
    <p style="font-size: 24px;"> #173 - Hollow Square Laminae I </p>
    how many hollow squares (see image below) can you construct using a million blocks? <br>
    <img style="max-width: 400px; max-height: 300px" src="projecteuler/limame squares example.png">
    <br>
    my first step was to draw a few little hollow squares to look for patterns. <br>
    initially i was thinking that i would have to account for two cases, when the "centre" of the square was 1x1 (odd) vs 2x2 (even). <br>
    i then thought of the hollow squares as a binary sequence, eg. the left square above would be 011. and tried to figure out a formula to count the number of cells from the binary sequence. <br>
    idk why this was my first approach as it would have been massively slower, huge overkill and really complicated. <br>
    luckily i noticed the number of cells in the hollow square was easily calculatable if you know the side length of the "inner" and "outer" square. <br>
    num_cells = outerN² - innerN² <br>
    now all i needed to do was define an iterative process which checks all outer and inner N's until num_cells exceeded 1 million. <br>
    the first thing i thought of was iterating thru "edge thickness" and outerN in a nested while loop. this way innerN = outerN - edgeThickness at each step. <br> 
    i found this problem easier then expected and i think this is a pretty efficient method. <br>
    pe difficulty: 30/100<br>
    my rating: 12/100 <br>
    <a href="projecteuler/limanae squares finished attempt.png" target="_blank"> show solution </a>
    <br><br><br>
</p>

<p>
    <p style="font-size: 24px;"> #174 - Hollow Square Laminae II </p>
    this one just expanded on the last problem. its a bit of word salad: <br>
    If t represents the number of tiles used, we shall say t=8 is type L(1) and t=32 is type L(2). the type describes how many unique hollow squares you can construct for a given t. <br>
    Now let N(n) be the number of t ≤ 1e6 such that t is type L(n). What is Σₙ N(n) for n = 1-10? <br>
    <br>
    so thats a lot of words but what N(n) is asking is: how many numbers under 1 million can you construct n unique hollow squares with? <br>
    using the code from the previous problem this is rather trivial. all i did was create an array which will store how many unique hollow squares each t can create. <br>
    because of the way the algorithm works in the previous problem it is guaranteed to generate all hollow squares using less then 1 mil cells without duplicates. <br>
    once the array is generated i just wrote a small function to count how many elements in the array equal some target value. <br>
    then sum that from 1 - 10. dont be like me i spent like 10 minutes getting it wrong because i was looping from 0 - 10 instead :( <br>

    pe difficulty: 40/100<br>
    my rating: 15/100 <br>
    <a href="projecteuler/limanae squares 2 finished attempt.png" target="_blank"> show solution </a>
    <br><br><br>
</p>

<p>
    <p style="font-size: 24px;"> #109 - Darts </p>
    how many unique checkouts are there in a game of darts, starting from 100 or less? <br>
    a checkout in darts must end with a double pointer and can use no more then 3 darts. <br>
    the thing that makes this problem hard is how unique is defined. so D2 S1 D1 != D1 S1 D2 because while made up of the same components they ended on different triples. <br>
    on the other hand  D2 D2 D1 != D2 D1 D2 == D1 D2 D2  and S1 S3 D1 == S3 S1 D1 <br>
    <br>
    my idea was simple, loop thru the possible 1, 2 and 3 dart checkouts, check if they sum to n, check if they end on a double, check if has been seen before. <br>
    the check if been seen before was the tricky part because of the strict uniqueness rules of the problem. <br>
    after a bit of fucking about i created an Area(value, mult) class which each describe a unique area of the dartboard. I put all of these into an array and sorted based on points value. <br>
    then when iterating thru the possible 2 and 3 dart checkouts, i did one of those progressive nested for loops (idk if they have a proper name) <br>
    this means the combos produced in the nested for loops are guaranteed to be unique. in my experience, this technique can best be applied with nested loops over the same sorted set. <br>
    <img style="max-width: 400px; max-height: 300px" src="projecteuler/109 progressive for loop demo.png" title="comparison of the search space seen by each for loop">
    <img style="max-width: 400px; max-height: 300px" src="projecteuler/109 algo demo.png" title="example of algorithm for a 2 dart checkout"> <br>

    as the number of nested for loops increases it saves more time compared to the regular method. i think 2^(d-1) times better where d is the depth of nested for loops. <br> 
    then i counted how many unique double areas that checkout had, this was the best way i could find to account for the strange uniqueness check. if it only had 1 unique double then i just continued. <br>
    if there were 2 double present in the checkout then there was one other solution, as depicted in the image above, so i added 2. <br>
    so in the right image above, the left yellow dot indicates a new found solution, say D2 D4. the other ? yellow dot represents the checkout D4 D2. <br>
    checking the uniqueness criteria we see these 2 are different, so we add 2 to the tally. if the checkout was S8 D2, we would only add 1, D2 S8 does not count. <br>
    if there were 3 unique doubles, then there were 2 other solutions. you may, like me, initially think this is meant to be 6 (3!), but remember only the last dart matters so we only add 3. <br>
    because only the total number of combinations was needed not the combinations themselves i neglected to create some sort of list of checkouts and just kept a running tally. <br>
    this was more difficult then it seemed on the tin. the difficultly mainly comes from working around the rules for what is and is not a unique checkout. <br>
    fortunately a dartboard only has 62 areas cos my algorithm is O(a³) where a is the number of areas on a dartboard. <br>
    i think my solution is decent (less then a second on my laptop :o) but would be interesting to see what the best way to solve if problem was larger; more darts, more areas, etc.  <br>
    pe difficulty: 45/100 <br>
    my rating: 30/100 <br>
    <a href="projecteuler/109 dart solution.png" target="_blank"> show solution </a>
    <br><br><br>
</p>


<p>
    <p style="font-size: 24px;"> #78 - Coin Partitions </p>
    the partition function p(n) describes how many unique ways you can separate a number n into different piles. p(5) = 7 you solve these pretty quickly with pen and paper. <br>
    <img style="max-width: 400px; max-height: 300px" src="projecteuler/78 partitions of 5.png" title="the 7 partitions of 5"> <br>
    it becomes not so trivial quite fast, p(100) = 190,569,292. the goal find the smallest n such that p(n) mod 1e6 = 0. <br>
    *turns out this is its own pe problem(#76 - Counting Summations), my dynamic sol gets this correct very quickly. <br>
    <br>
    this problem is similar to #31 - coins sums, except we we are not limited to only groups of 1, 2, 5, 10, etc. and we do not know what our final value of n will be. <br>
    so i started by adjusting the code from my solution of that problem to account for any pile size. this worked, however is very slow due to the recalculating the same thing many times. <br>
    if i had only optimised my code at the time this problem would have been free. <br>
    <br>
    okay a while later. problem not free. i thought i got a decent dynamic solution (
        <a href="projecteuler/78 dynamic attempt.png" target="_blank"> dynamic attempt </a>
    ), always gives same answer as recursive (up to n=50). <br>
    so i modify it to run in a while loop like fashion, it gives an answer of 2301. pe says X wrong. wtf? recheck to bigger numbers with recursive, still looks good. <br>
    in my confusion i go to google, all answers i see are refering to euler's pentagonal numbers and recurrence relations, nothing like my dynamic programming solution. <br>
    also i found what the real answer was. spoiler: not 2301, like 30x bigger. well i try my dp solution upto 60k, and its slow, too slow. O(n²) is not enough. <br>
    as for why i was getting 2301, im not sure. hopefully if i can solve with this other method, i can compare and see what went wrong. <br>
    i figured i could use similar logic to # 31, which maybe you can, but just too slow even with dynamic sol :(. so i am now going to try the method i read about online.  <br>
    <br>
    i think a lot of the difficulty if this problem is researching, once you find <a href="https://en.wikipedia.org/wiki/Pentagonal_number_theorem" target="_blank">
        Euler's pentagonal number thereom</a> it is not too hard to apply <br>
    this was a bit :/ for me, cos i didnt realise there would be problems in this list that require niche mathematical theorems to solve. <br> 
    so this is my implementation. i cant say i understand why this recurrence works or what pentagonal numbers have to do with it, but it works and takes like 10 seconds. <br>
    <a href="projecteuler/78 solution.png" target="_blank"> show solution </a> <br>
    pe difficulty: 30/100 <br>
    my rating: 50/100*  <br>
    <br><br><br>    

</p>
